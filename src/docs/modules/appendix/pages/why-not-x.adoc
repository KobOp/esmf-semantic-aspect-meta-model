////
Copyright (c) 2020 Robert Bosch Manufacturing Solutions GmbH

See the AUTHORS file(s) distributed with this work for additional information regarding authorship. 

This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/
SPDX-License-Identifier: MPL-2.0
////

:page-partial:
:sectnums:

[appendix]
[[why-not-x]]
== Why not X instead of {meta-model-full-name}?


=== Why not use X to specify Aspect Models?

An extensive evaluation based on preliminary use cases was conducted to classify existing formats
and languages for the formulation of Aspect Models. This section summarizes the criteria and
candidates.

==== General Assumptions

Generally, the goal of Aspect Models is describing _information models_ (as opposed to _data
models_). This means that the Meta Model used to describe Aspect Models should allow the
specification of context beyond mere data. For example, a data model would specify for a
`temperature` property the data type `float`, while an information model would also specify
information about the fact that the value was measured from a sensor, that the value has a certain
range (that corresponds to the value range given in the data sheet of the respective sensor), that
the value is given in degrees Celsius and a human-readable documentation.

Beyond this, the following use cases should specifically be supported:

. Code generation for Aspect Implementations and Solution Client implementations. As multiple
programming languages and environments are going to be supported (e.g., Java, .NET Core, JavaScript),
the model format should be implementation language agnostic.

. Validation of data. Constraints, such as which properties in which classes and which data ranges
on which properties need to be validated against data at runtime. The necessary validation code (or
comparable constructs) should be able to use the model or be directly generated from the model.

. Enable interchange between different tooling for the description of domain-specific modeling
tools. The format needs to be flexible and generic enough to allow model mapping or model
transformation to other formalisms. Being based on an open standard or de-facto standard and
consequently being supported by existing/third-party tools is a plus.

==== Why not JSON Schema or Entity-Relationship-Modeling?

The goal of describing _information models_ rules out modeling approaches that are only applicable
to the data itself. Examples of such models are JSON Schema (and similar techniques such as XML
schema) and Entity-Relationship-Models. While existing tool support for data validation is good, the
thorough description of domain semantics is not the focus of such approaches and therefore ranges
between being inconvenient to outright impossible.

==== Why not Eclipse Vorto's DSL?

https://www.eclipse.org/vorto/[Eclipse Vorto] provides a DSL (Domain Specific Language) with a
custom syntax for the specification of device interfaces. The expressive power of the language is
intentionally limited to the domain concepts of IoT device interfaces. Vorto provides model
validation and code generators that take models as an input. However, there is a strong conceptual
mismatch between the intended use of Vorto's DSL and the goals of Aspect Models that can not easily
be dispelled due to intrinsic meta-model structure and semantics. For example, Vorto Models have no
concept comparable to Characteristics, don't allow the specification of Entity or Characteristics
instances and use a different terminology than Aspect Models with no option to change or customize.
Furthermore, due to the fact that the DSL is specific to Vorto, there are no other tools or
libraries that support working with the models.

==== Why not OWL?

The Web Ontology Language (OWL, <<owl2>>) is the de-facto standard language for the description of
_https://en.wikipedia.org/wiki/Ontology%20(information_science)[Ontologies]_, i.e., the formal
description of things, sets of things and relations between things. "`OWL is a computational
logic-based language such that knowledge expressed in OWL can be reasoned with by computer programs
either to verify the consistency of that knowledge or to make implicit knowledge explicit.`" <<owl2>>
When speaking of semantic modeling, OWL is often the first choice of modeling language.

In OWL, both the verification of consistency and inference of knowledge are based on the
https://en.wikipedia.org/wiki/Open-world_assumption[open-world assumption], which means that what is
not known to be true or false is unknown. For example, having a class `Person` that requires a
property `name` and an instance of `Person` that has no `name` specified is no inconsistency -- it
just means that its `name` is currently unknown. This makes OWL well-suited to describe parts of a
domain that are later combined with other descriptions of parts of the same domain to end up with a
consistent and preferably complete overall description. Verification and inference are based on data
that is structured in a directed graph.

However, the main features of OWL -- ascertaining consistency in a potentially incompletely modeled
world and the inference of knowledge -- are both not goals of Aspect Models. On the other hand,
while some of the (mainly structural) constraints of an Aspect Model could be represented in OWL,
other parts focused on the validation of runtime data can not be represented. For example, a fact
like "`there needs to be a certain tool in a certain machine`" could easily be modeled in OWL, while
facts like "`this Property describes an ordered set of data of a given structure`" are
disproportionately complex to model in comparison to what OWL provides that an Aspect Model can make
use of. Additionally, closed-world semantics (the opposite of the open-world assumption) are
required for Aspect Models, as they are used to model data where, for example, a missing mandatory
property should directly result in a validation error.

Standard tools such as reasoners could therefore not be used unchanged to validate Aspect Models
described in OWL. Many conceptual constraints on what Aspect Models should be able to express are
based on the assumption that runtime data that corresponds to an Aspect is structured in a tree
(e.g., given in JSON). While possible to express in OWL, this would place the responsibility to get
this right on the model creator, who would need to be intimately familiar with the discipline of
Ontology Engineering, because standard OWL semantics allow more degrees of freedom. Figuratively
speaking, OWL is an all-terrain vehicle while we try to build a rail network. To a certain degree,
we want to exchange flexibility with ease of use in the target domain, increase modeling speed and
reduce the number of potential modeling errors by reducing the degrees of freedom.

=== Why not use X to specify the Aspect Meta Model itself?

After deciding that a custom meta model and a suitable way to specify it is required for the
description of Aspect Models, an evaluation of how to specify the meta model itself was conducted.
As Aspect Models are specified in RDF, a straightforward and extensible way based on open standards
was adopted for the implementation of the Aspect Meta Model. The Aspect Meta Model is defined as a
combination of RDF vocabularies and a number of "`shapes`" defined SHACL <<shacl>>, a language for
validating RDF graphs against a set of conditions which in turn is based on SPARQL <<sparql>>, the
RDF query language. This combination of technologies is a natural fit for the description of
{meta-model-full-name}'s closed world semantics.

* OWL could not have been used for this for reasons similar to its unfitness for the description of
  Aspect Models, i.e., in addition to OWL's intrinsic semantics, many validations would have to be
  implemented manually in addition to standard reasoning, thus diminishing OWL's overall value. This
  said, it would be possible to express parts of {meta-model-full-name}'s semantics in OWL if
  necessary.

* The Meta Model could have been implemented in a combination of
  https://en.wikipedia.org/wiki/Unified_Modeling_Language[UML] and
  https://en.wikipedia.org/wiki/Object_Constraint_Language[OCL]. However, on the one hand, this
  approach would have required increased complexity due to the use of an UML-to-RDF-mapping and on
  the other hand, there exists not as much documentation and tool support for the respective
  technologies.

=== Why not use well-known RDF vocabularies or namespaces?

For model authors that have worked with RDF before, the use of the `bamm:` namespace as opposed to
using well-known vocabularies such as RDFS or
http://www.dublincore.org/specifications/dublin-core/dcmi-terms/[Dublin Core] is noticeable. With
the exception of the XSD namespace for datatypes, {meta-model-abbr} and Aspect Models define their
vocabulary in namespaces specific to {meta-model-abbr}. There are two reasons for this:

* {meta-model-abbr} namespaces use URNs instead of URLs as element identifiers. This is to avoid
  confusion about resolvability: Working with Aspect Models (e.g., validating them or generating code
  from them) must work in a stand-alone (i.e., offline) fashion. Avoiding using URLs that are not
  supposed to be resolved avoids confusion among developers.

* {meta-model-abbr} namespaces are all versioned: Each version's semantics are self-contained.
  Should semantics of one version change, elements of previous versions can still be processed as
  before. This is not possible when relying on externally defined, non-versioned namespaces.
